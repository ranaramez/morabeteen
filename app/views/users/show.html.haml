.profile-wrapper
  .container
    .profile-header.row
      .user-avatar.pull-left
        = image_tag 'default-avatar.png', class: 'img-polaroid'
        / = image_tag @user.avatar.profile.url
      .media-body
        %h3.media-heading
          = @user.name
        %ul.badges-list
          %li.badges.abubakr
          %li.badges.abuobayda
          %li.badges.omr
          %li.badges.ali
        .span1.pull-left
          .numbers{id: "#{@user.id}-acc-score"}
            = total_acc_score
          %label
            درجة

    %br

    .timeline-wrapper.row
      .week-wrapper.clearfix
        .span3.week-level
          اختر المرحله لهذا الاسبوع

        .span9.days-wrapper
          - if @schedules.present?
            - grouped_schedules = @schedules.desc(:start_date).group_by(&:start_date)
            - grouped_schedules.keys.each_with_index do |s,x|
              - start_date = grouped_schedules[s].first.start_date
              - end_date = grouped_schedules[s].first.end_date
              - user_level = current_user.level(start_date)
              - current_level = user_level.level if user_level
              - level_schedules = level_schedules(grouped_schedules[s], current_level)
              - unless missed_schedule?(start_date, end_date)
                %span.day-activity
                  .schedule-item{id: "option-level-select"}
                    = render partial: "level_select", locals: {start_date: start_date, end_date: end_date, schedules: grouped_schedules[s], current_level: current_level}

                  - start_range = x == 0 ? (grouped_schedules[s].first.end_date < Date.today  ? grouped_schedules[s].first.end_date : Date.today) : grouped_schedules.keys[x-1] - 1
          - else
            %p
              No schedules yet!

        .span1.week-points.pull-right
          %label
            0 درجة

    .timeline.flow
      .main-content.clearfix
        %section.schedule-activity
          #days-activity
            %ul.schedules
              - if @schedules.present?
                - grouped_schedules = @schedules.desc(:start_date).group_by(&:start_date)
                - grouped_schedules.keys.each_with_index do |s,x|
                  - start_date = grouped_schedules[s].first.start_date
                  - end_date = grouped_schedules[s].first.end_date
                  - user_level = current_user.level(start_date)
                  - current_level = user_level.level if user_level
                  - level_schedules = level_schedules(grouped_schedules[s], current_level)
                  - unless missed_schedule?(start_date, end_date)
                    %li.clearfix
                      .calendar
                        .date
                          = t('level.selected')
                      .schedule-item{id: "option-level-select"}
                        = render partial: "level_select", locals: {start_date: start_date, end_date: end_date, schedules: grouped_schedules[s], current_level: current_level}

                    - start_range = x == 0 ? (grouped_schedules[s].first.end_date < Date.today  ? grouped_schedules[s].first.end_date : Date.today) : grouped_schedules.keys[x-1] - 1
                    %li.week-points.clearfix
                      .calendar
                        .date
                          = t('achievement.week_score')
                      .schedule-item
                        .content.clearfix
                          %h4
                            %span.numbers{id: "#{start_range.strftime('%y%m%d')}-week-score"}
                              = total_week_score(s, start_range)
                            = t('common.points')
                    %ul
                      .schedule{id: "#{start_range}-to-#{s}"}
                        = render partial: 'users/populate_timeline', locals: {start_range: start_range, end_range: s, schedules: grouped_schedules[s], completed_tasks: @completed_tasks}

              - else
                No schedules yet!
